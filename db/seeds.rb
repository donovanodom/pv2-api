# This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the bin/rails db:seed command (or created alongside the database with db:setup).
#
# Examples:
#
#   movies = Movie.create([{ name: "Star Wars" }, { name: "Lord of the Rings" }])
#   Character.create(name: "Luke", movie: movies.first)

algorithm1 = Algorithm.create(
    title: "Count Unguarded Cells in the Grid",
    content: "\u003Cp\u003EYou are given two integers \u003Ccode\u003Em\u003C/code\u003E and \u003Ccode\u003En\u003C/code\u003E representing a \u003Cstrong\u003E0-indexed\u003C/strong\u003E \u003Ccode\u003Em x n\u003C/code\u003E grid. You are also given two 2D integer arrays \u003Ccode\u003Eguards\u003C/code\u003E and \u003Ccode\u003Ewalls\u003C/code\u003E where \u003Ccode\u003Eguards[i] = [row\u003Csub\u003Ei\u003C/sub\u003E, col\u003Csub\u003Ei\u003C/sub\u003E]\u003C/code\u003E and \u003Ccode\u003Ewalls[j] = [row\u003Csub\u003Ej\u003C/sub\u003E, col\u003Csub\u003Ej\u003C/sub\u003E]\u003C/code\u003E represent the positions of the \u003Ccode\u003Ei\u003Csup\u003Eth\u003C/sup\u003E\u003C/code\u003E guard and \u003Ccode\u003Ej\u003Csup\u003Eth\u003C/sup\u003E\u003C/code\u003E wall respectively.\u003C/p\u003E\n\n\u003Cp\u003EA guard can see \u003Cb\u003Eevery\u003C/b\u003E cell in the four cardinal directions (north, east, south, or west) starting from their position unless \u003Cstrong\u003Eobstructed\u003C/strong\u003E by a wall or another guard. A cell is \u003Cstrong\u003Eguarded\u003C/strong\u003E if there is \u003Cstrong\u003Eat least\u003C/strong\u003E one guard that can see it.\u003C/p\u003E\n\n\u003Cp\u003EReturn\u003Cem\u003E the number of unoccupied cells that are \u003Cstrong\u003Enot\u003C/strong\u003E \u003Cstrong\u003Eguarded\u003C/strong\u003E.\u003C/em\u003E\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/example1drawio2.png\" style=\"width: 300px; height: 204px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 7\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E The guarded and unguarded cells are shown in red and green respectively in the above diagram.\nThere are a total of 7 unguarded cells, so we return 7.\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/example2drawio.png\" style=\"width: 200px; height: 201px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 4\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E The unguarded cells are shown in green in the above diagram.\nThere are a total of 4 unguarded cells, so we return 4.\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 &lt;= m, n &lt;= 10\u003Csup\u003E5\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E2 &lt;= m * n &lt;= 10\u003Csup\u003E5\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 &lt;= guards.length, walls.length &lt;= 5 * 10\u003Csup\u003E4\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E2 &lt;= guards.length + walls.length &lt;= m * n\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Eguards[i].length == walls[j].length == 2\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E0 &lt;= row\u003Csub\u003Ei\u003C/sub\u003E, row\u003Csub\u003Ej\u003C/sub\u003E &lt; m\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E0 &lt;= col\u003Csub\u003Ei\u003C/sub\u003E, col\u003Csub\u003Ej\u003C/sub\u003E &lt; n\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003EAll the positions in \u003Ccode\u003Eguards\u003C/code\u003E and \u003Ccode\u003Ewalls\u003C/code\u003E are \u003Cstrong\u003Eunique\u003C/strong\u003E.\u003C/li\u003E\n\u003C/ul\u003E\n",
    code: "const countUnguarded \\u003D function(m, n, guards, walls) {\\u000A  \\u000A  // create matrix based based on m and n values\\u000A  const mat \\u003D Array(m).fill().map(() \\u003D\\u003E Array(n).fill(0))\\u000A  \\u000A  // store row and column lengths and initialize total number of cells\\u000A  const row \\u003D mat.length, col \\u003D mat[0].length\\u000A  let total \\u003D row * col\\u000A  \\u000A  // iterate through walls array and set wall locations in matrix\\u000A  // each time we encounter a wall, decrement the total\\u000A  for(const [x,y] of walls){\\u000A    mat[x][y] \\u003D \\u0027W\\u0027\\u000A    total\\u002D\\u002D\\u000A  }\\u000A  \\u000A  // create a traversal function to follow the paths each guard sees\\u000A  const traverse \\u003D (initx, inity) \\u003D\\u003E {\\u000A    \\u000A    // initialize a queue with the coordinates of a guard and an object\\u000A    // with keys for each direction of traversal and corresponding values\\u000A    const q \\u003D [[initx,inity,\\u0027\\u0027]], dirs \\u003D {\\u0027u\\u0027:[\\u002D1,0],\\u0027d\\u0027:[1,0],\\u0027l\\u0027:[0,\\u002D1],\\u0027r\\u0027:[0,1]}\\u000A    \\u000A    // iterate through queue to follow the paths each guard sees\\u000A    while(q.length){\\u000A      const [x,y,dir] \\u003D q.shift()\\u000A      \\u000A      // if direction not provided this is our starting point\\u000A      // we need to check all four directions for valid paths\\u000A      if(!dir){\\u000A        Object.keys(dirs).map((key) \\u003D\\u003E {\\u000A          \\u000A          // create values for a possible next coordinates in our matrix\\u000A          // check the values to see if they are in bounds and not a wall or guard\\u000A          const [dirX, dirY] \\u003D dirs[key], nextX \\u003D x + dirX, nextY \\u003D y + dirY\\u000A          if(nextX \\u003E\\u003D 0 \\u0026\\u0026 nextY \\u003E\\u003D 0 \\u0026\\u0026 nextX \\u003C row \\u0026\\u0026 nextY \\u003C col \\u0026\\u0026 mat[nextX][nextY] !\\u003D \\u0027W\\u0027 \\u0026\\u0026 mat[nextX][nextY] !\\u003D \\u0027G\\u0027){\\u000A            \\u000A            // decrement total if next is a valid coordinate and has not already been marked as seen\\u000A            // set matrix value to 1 for seen and push next coordinates and direction to queue\\u000A            if(mat[nextX][nextY] \\u003D\\u003D 0) total\\u002D\\u002D\\u000A            mat[nextX][nextY] \\u003D 1\\u000A            q.push([nextX,nextY,key])\\u000A          }\\u000A        })\\u000A      }else{\\u000A        \\u000A        // create values for a possible next coordinate in our matrix\\u000A        // check the values to see if they are in bounds and not a wall or guard\\u000A        const [dirX, dirY] \\u003D dirs[dir], nextX \\u003D x + dirX, nextY \\u003D y + dirY\\u000A        if(nextX \\u003E\\u003D 0 \\u0026\\u0026 nextY \\u003E\\u003D 0 \\u0026\\u0026 nextX \\u003C row \\u0026\\u0026 nextY \\u003C col \\u0026\\u0026 mat[nextX][nextY] !\\u003D \\u0027W\\u0027 \\u0026\\u0026 mat[nextX][nextY] !\\u003D \\u0027G\\u0027){\\u000A          \\u000A          // decrement total if next is a valid coordinate and has not already been marked as seen\\u000A          // set matrix value to 1 for seen and push next coordinates and direction to queue\\u000A          if(mat[nextX][nextY] \\u003D\\u003D 0) total\\u002D\\u002D\\u000A          mat[nextX][nextY] \\u003D 1\\u000A          q.push([nextX,nextY,dir])\\u000A        }\\u000A      }\\u000A    }\\u000A  }\\u000A  \\u000A  // iterate through guards array and set guard locations in matrix\\u000A  // each time we encounter a guard, decrement the total\\u000A  for(const [x,y] of guards){\\u000A    mat[x][y] \\u003D \\u0027G\\u0027\\u000A    total\\u002D\\u002D\\u000A  }\\u000A  \\u000A  // iterate through guards array and run traversal function for each coordinate\\u000A  for(const [x,y] of guards){\\u000A    traverse(x, y, mat, row, col, total)\\u000A  }\\u000A  \\u000A  // return the remaining total of spaces unseen and not a wall or guard\\u000A  return total\\u000A}\\u000A\\u000A\n",
    tags: [
      "Array",
      "Matrix",
      "Simulation"
    ]
)